require 'socket'
require 'digest'

module Synapse
  class Haproxy
    attr_reader :opts
    def initialize(opts)
      super()

      %w{global defaults reload_command}.each do |req|
        raise ArgumentError, "haproxy requires a #{req} section" if !opts.has_key?(req)
      end

      req_pairs = {
        'do_writes' => 'config_file_path',
        'do_socket' => 'socket_file_path',
        'do_reloads' => 'reload_command'}

      req_pairs.each do |cond, req|
        if opts[cond]
          raise ArgumentError, "the `#{req}` option is required when `#{cond}` is true" unless opts[req]
        end
      end

      @opts = opts

      # how to restart haproxy
      @restart_interval = 2
      @restart_required = true
      @last_restart = Time.new(0)
    end

    def update_config(watchers)
      # if we support updating backends, try that whenever possible
      if @opts['do_socket']
        update_backends(watchers) unless @restart_required
      else
        @restart_required = true
      end

      # generate a new config
      new_config = generate_config(watchers)

      # if we write config files, lets do that and then possibly restart
      if @opts['do_writes']
        write_config(new_config)
        restart if @opts['do_reloads'] && @restart_required
      end
    end

    # generates a new config based on the state of the watchers
    def generate_config(watchers)
      new_config = generate_base_config + "\n"

      new_config << watchers.map {|w| generate_listen_stanza(w)}.join("\n")
      new_config << watchers.map {|w| generate_backend_stanza(w)}.join("\n")

      log.debug "synapse: new haproxy config: #{new_config}"
      return new_config
    end

    # generates the global and defaults sections of the config file
    def generate_base_config
      base_config = "# auto-generated by synapse at #{Time.now}\n"

      %w{global defaults}.each do |section|
        base_config << "\n#{section}\n"
        @opts[section].each do |option|
          base_config << "\t#{option}\n"
        end
      end

      if @opts['extra_sections']
        @opts['extra_sections'].each do |title, section|
          base_config << "\n#{title}\n"
          section.each do |option|
            base_config << "\t#{option}\n"
          end
        end
      end

      return base_config
    end

    # generates an individual stanza for a particular watcher
    def generate_listen_stanza(watcher)
      if not watcher.haproxy.has_key?("port") then
        log.warn "synapse: no port found for watcher #{watcher.name}"
        return ""
      end

      stanza = "\nlisten #{watcher.name}_in localhost:#{watcher.haproxy['port']}\n"

      watcher.haproxy['listen'].each do |line|
        stanza << "\t#{line}\n"
      end

      stanza << "\tdefault_backend #{watcher.name}\n"

      return stanza
    end

    def generate_backend_stanza(watcher)
      if watcher.backends.empty?
        log.warn "synapse: no backends found for watcher #{watcher.name}"
        return ""
      end

      stanza = "\nbackend #{watcher.name}\n"

      watcher.haproxy['backend'].each do |line|
        stanza << "\t#{line}\n"
      end

      watcher.backends.shuffle.each do |backend|
        backend_name = construct_name(backend)
        stanza << "\tserver #{backend_name} #{backend['host']}:#{backend['port']} #{watcher.haproxy['server_options']}\n"
      end
      return stanza
    end

    # tries to set active backends via haproxy's stats socket
    # because we can't add backends via the socket, we might still need to restart haproxy
    def update_backends(watchers)
      # first, get a list of existing servers for various backends
      begin
        s = UNIXSocket.new(@opts['socket_file_path'])
        s.write('show stat;')
        info = s.read()
      rescue StandardError => e
        log.warn "synapse: unhandled error reading stats socket: #{e.inspect}"
        @restart_required = true
        return
      end

      # parse the stats output to get current backends
      cur_backends = {}
      info.split("\n").each do |line|
        next if line[0] == '#'

        parts = line.split(',')
        next if ['FRONTEND', 'BACKEND'].include?(parts[1])

        cur_backends[parts[0]] ||= []
        cur_backends[parts[0]] << parts[1]
      end

      # build a list of backends that should be enabled
      enabled_backends = {}
      watchers.each do |watcher|
        enabled_backends[watcher.name] = []
        next if watcher.backends.empty?

        unless cur_backends.include? watcher.name
          log.debug "synapse: restart required because we added new section #{watcher.name}"
          @restart_required = true
          return
        end

        watcher.backends.each do |backend|
          backend_name = construct_name(backend)
          unless cur_backends[watcher.name].include? backend_name
            log.debug "synapse: restart required because we have a new backend #{watcher.name}/#{backend_name}"
            @restart_required = true
            return
          end

          enabled_backends[watcher.name] << backend_name
        end
      end

      # actually enable the enabled backends, and disable the disabled ones
      cur_backends.each do |section, backends|
        backends.each do |backend|
          if enabled_backends[section].include? backend
            command = "enable server #{section}/#{backend};"
          else
            command = "disable server #{section}/#{backend};"
          end

          # actually write the command to the socket
          begin
            s = UNIXSocket.new(@opts['socket_file_path'])
            s.write(command)
            output = s.read()
          rescue StandardError => e
            log.warn "synapse: unknown error writing to socket"
            @restart_required = true
            return
          else
            unless output == "\n"
              log.warn "synapse: socket command #{command} failed: #{output}"
              @restart_required = true
              return
            end
          end
        end
      end
    end

    # writes the config
    def write_config(new_config)
      begin
        old_config = File.read(@opts['config_file_path'])
      rescue Errno::ENOENT => e
        log.info "synapse: could not open haproxy config file at #{@opts['config_file_path']}"
        old_config = ""
      end

      if old_config == new_config
        return false
      else
        File.open(@opts['config_file_path'],'w') {|f| f.write(new_config)}
        return true
      end
    end

    # restarts haproxy
    def restart
      # sleep if we restarted too recently
      delay = (@last_restart - Time.now) + @restart_interval
      sleep(delay) if delay > 0

      # do the actual restart
      res = `#{opts['reload_command']}`.chomp
      raise "failed to reload haproxy via #{opts['reload_command']}: #{res}" unless $?.success?

      @last_restart = Time.now()
      @restart_required = false
    end

    # used to build unique, consistent haproxy names for backends
    def construct_name(backend)
      address_digest = Digest::SHA256.hexdigest(backend['host'])[0..7]
      return "#{backend['name']}:#{backend['port']}_#{address_digest}"
    end
  end
end
